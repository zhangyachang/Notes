---
弹性盒模型
---



### 弹性盒模型

**注意点	**弹性盒子模型，如果没有宽高，那么宽度由内容撑开，高度继承父类

弹性盒子

​	1.布局的传统解决方案，基于盒状模型，依赖display属性+position属性+float属性，

​	它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现

​	2.2009，w3c提出了一种新的方案-flex布局，可以简便、完整、响应式地实现各种页面的布局。

​	目前，他已经得到了所有浏览器的支持，这意味着，现在就能很安全的使用这项功能

​	3.采用flex布局的元素，成为flex容器（flex container）,简称"容器"，它的所有子元素自动成为容器成员，成为flex项目，（fiex item）,简称“项目”

### 容器属性

首要条件: 父元素

```css
display:flex;
```

##### flex-direction

​	定义：**决定主轴的方向**

​	取值：

- flex-direction:row; 	从左到右排列（abc）


- row-reverse   	  从左到右排列，但元素顺序与row相反（cba)
	 column     	          主轴为垂直方向，起点在上沿。
- column-reverse      主轴为垂直方向，起点在下沿、

##### flex-wrap

​	定义：该属性控制flex容器是**单行或者多行**

​	取值：

-  nowrap： 不换行。该情况下flex子项可能会溢出容器（默认值）
-  wrap：flex容器为多行。该情况下flex子项溢出的部分会被放置到新行，换行。
-  wrap-reverse:   反转 wrap 排列。（注意：不是倒序）

##### flex-flow

​	定义： flex-direction和flex-wrap的复合简写形式，默认为 	row nowrap

​	取值： 

- flex-direction
- flex-wrap

写法： **flex-flow: flex-direction flex-wrap**

##### justify-content

​	定义：定义了项目在**主轴方向的对齐方式**

- justify-content:flex-start;(左对齐)
- justify-content: flex-end；（右对齐）
- justify-content: center；（居中对齐）
- justify-content: space-between；（两端对齐，项目之间间隔相等）
- justify-content: space-around；（每个项目两侧间隔相等）

##### align-items

​	定义：弹性盒子元素**在交叉轴如何对齐**

​	取值：

- align-items:stretch;(默认值)
- align-items：flex-end;（交叉轴的终点对齐）
- align-items：center;（交叉轴的中点对齐）
- align-items：baseline;（项目的第一行文字的基线对齐）
- align-items：flex-start;（交叉轴的起点对齐）

##### align-content

​	定义：定义了多跟轴线对齐方式，如果项目只有一根轴线，则不起作用

- align-content: stretch（默认值，轴线占满整个交叉轴）
- align-content:  flex-star（与交叉轴起点对齐）
- align-content: flex-end（与交叉轴终点对齐）
- align-content: center（与交叉轴中点对齐）
- align-content: space-between（与交叉轴两端对齐，之间平均分配）
- align-content: space-around（交叉轴两侧间隔相等）

### 项目属性

##### flex-grow

​	定义项目放大比例，默认为0（即如果存在剩余空间，也不放大）

​	如果所有项目的**flex-grow属性都为1**，则他们将**等分剩余空间**（如果有剩余空间的话）。

​	如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的

​	剩余空间将比其他项多一倍。

第一种情况：**没有加宽度，直接按照flex-grow按比例分配**，没给则不分配

​			ps：对于**弹性盒子分配不准**的项都加上width:0%;

```css
ul li{width:0%}
ul li:nth-child(1){flex-grow:1;}
ul li:nth-child(2){flex-grow:1;}
ul li:nth-child(3){flex-grow:3;}
/*
	没有给宽度的时候    (400/5)*1 = 80px
					  (400/5)*1 = 80px
					  (400/5)*3 = 240px
	没有给宽度的时候造成分配不准确，那么给所有的项目 width:0;
*/
```

**第二种情况：加了宽度**

​	算法：实际宽度=初始宽度+flex-grow比例

```css
ul li:nth-child(1){width:100px; flex-grow:1;}
ul li:nth-child(2){width:100px; flex-grow:1;}
ul li:nth-child(3){width:100px; flex-grow:3;}
/*
	项目给了宽度的时候，
	width = 实际宽度 + 分配宽度
	假如父级是400  多余出来的宽度 = 400-300 = 100
	第一个li分配的宽度是  （100/5）*1 = 20px  它的宽度为 100+20=120px
	第二个li分配的宽度是  （100/5）*1 = 20px  		100+20=120px
	第三个li分配的宽度是   （100/5）*3 = 60px      100+60 = 160px
*/	
```

##### flex-shrink

​	定义：定义项目缩小比例，默认为1，即如果空间不足，该项目将缩小。

​	如果所有项目的flex-shrink属性都为1，当空间不足时,都将等比例缩小。

​	如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小，负值对该属性无效,

​	**加权占比重 负担超出的部分**

```css
.box ul li{}
.box ul li:nth-child(1){width:200px; flex-shrink:1;}
.box ul li:nth-child(2){width:400px; flex-shrink:1;}
.box ul li:nth-child(3){width:400px; flex-shrink:2;}
/*
	设父级是400  超出了1000-400 = 600px
	加权综合 200 + 400 + 400*2 = 1400；
	收缩值 = （项目的宽度*shrink）/综合  * 超出值
	200*1/1400 * 600 = 600/7    85.7
	400/1400 * 600 = 1200/7 = 171.42
	800/1400 * 600 = 2400/7    342.8
	实际宽度 = 宽度 - 收缩值
				200-85 = 115
				400-171.42 = 229
				400-342.8 = 58 	
*/
```

##### flex-basis

​	定义： flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（宽度）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小（没有宽度即为内容宽度）。

```js
	flex-basis：通俗的说就是宽度，在分配空间的时候要
	要根据这一个值来进行计算
	默认值auto（width属性或者内容撑开的宽度）
	也就是说，如果有这个属性，则按照这个属性进行分配
	如果没有，按照width分配，width也没有，
	按照内容撑开的宽度分配	
```

##### flex

​	定义：定义： flex-grow，flex-shrink，flex-basis的复合属性。

​	建议优先使用这个属性，而不是单独写分离的属性，因为浏览器会推算相关的值。

​	flex：0 1 auto；（默认）;

##### align-self

​	定义： align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。

​	默认值为auto，表示继承	父元素的align-items属性，如果没有父元素，则等同于stretch。

​	取值	align-self: flex-start | flex-end | center | baseline | stretch;

##### order

​	默认是0，定义单个项目的顺序

​	order排序，值越大，越靠后，并且还可以拉到负值

```css
ul li:nth-child(1){order:0;}
ul li:nth-child(2){order:3;}
ul li:nth-child(3){order:4;}
ul li:nth-child(4){order:-1;}
ul li:nth-child(5){order:8;}
ul li:nth-child(6){order:-7;}
```
