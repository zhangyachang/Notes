# 泛型

软件工程的一个重要部分就是构建组件，组件不仅需要有定义良好和一致的 API，也需要是可复用的（reusable）。好的组件不仅能够兼容今天的数据类型，也能适用于未来可能出现的数据类型，这在构建大型软件系统时会给你最大的灵活度。

在比如 C# 和 Java 语言中，用来创建可复用组件的工具，我们称之为泛型（generics）。利用泛型，我们可以创建一个支持众多类型的组件，这让用户可以使用自己的类型消费（consume）这些组件。

## Generics 初探（Hello World of Generics）

让我们开始写第一个泛型，一个恒等函数（identity function）。所谓恒等函数，就是一个返回任何传进内容的函数。你也可以把它理解为类似于 `echo` 命令。

不借助泛型，我们也许需要给予恒等函数一个具体的类型：

```ts
function identity(arg: number): number {
  return arg;
}
```

或者，我们使用 `any` 类型：

```ts
function identity(arg: any): any {
  return arg;
}
```

尽管使用 `any` 类型可以让我们接受任何类型的 `arg` 参数，但也让我们丢失了函数返回时的类型信息。如果我们传入一个数字，我们唯一知道的信息是函数可以返回任何类型的值。

所以我们需要一种可以捕获参数类型的方式，然后再用它表示返回值的类型。这里我们用了一个**类型变量（type variable）**，一种用在类型而非值上的特殊的变量。

```ts
function identity<Type>(arg: Type): Type {
  return arg;
}
```

现在我们已经给恒等函数加上了一个类型变量 `Type`，这个 `Type` 允许我们捕获用户提供的类型，使得我们在接下来可以使用这个类型。这里，我们再次用 `Type` 作为返回的值的类型。在现在的写法里，我们可以清楚的知道参数和返回值的类型是同一个。

现在这个版本的恒等函数就是一个泛型，它可以支持传入多种类型。不同于使用 `any`，它没有丢失任何信息，就跟第一个使用 `number` 作为参数和返回值类型的的恒等函数一样准确。

在我们写了一个泛型恒等函数后，我们有两种方式可以调用它。第一种方式是传入所有的参数，包括类型参数：
